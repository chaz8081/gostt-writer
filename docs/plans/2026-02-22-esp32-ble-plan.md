# ESP32-S3 BLE Output Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add BLE output to gostt-writer so transcribed text streams to an ESP32-S3 running ToothPaste firmware, which types it via USB HID on any target device.

**Architecture:** New `internal/ble/` package tree (crypto, protocol, client) with a `BLEInjector` in `internal/inject/`. Config gains `inject.ble` section. A `--ble-pair` CLI flag handles one-time device pairing. The `tinygo-org/bluetooth` library provides the BLE GATT client on macOS.

**Tech Stack:** Go stdlib crypto (`crypto/ecdh`, `crypto/aes`, `crypto/cipher`, `crypto/rand`), `golang.org/x/crypto/hkdf`, `tinygo-org/bluetooth`, hand-encoded protobuf.

**Design doc:** `docs/plans/2026-02-22-esp32-ble-design.md`

---

## Task 1: Protobuf Hand-Encoding (protocol package)

Encode/decode the three ToothPaste protobuf message types without a protoc dependency.

**Files:**
- Create: `internal/ble/protocol/proto.go`
- Create: `internal/ble/protocol/proto_test.go`

**Step 1: Write failing tests for protobuf encoding**

```go
// internal/ble/protocol/proto_test.go
package protocol

import (
	"bytes"
	"testing"
)

func TestMarshalKeyboardPacket(t *testing.T) {
	msg := "hello"
	got := MarshalKeyboardPacket(msg)
	// Field 1 (string): tag=0x0a, len=5, "hello"
	// Field 2 (uint32): tag=0x10, varint=5
	want := []byte{0x0a, 0x05, 'h', 'e', 'l', 'l', 'o', 0x10, 0x05}
	if !bytes.Equal(got, want) {
		t.Errorf("MarshalKeyboardPacket(%q) = %x, want %x", msg, got, want)
	}
}

func TestMarshalKeyboardPacketEmpty(t *testing.T) {
	got := MarshalKeyboardPacket("")
	// Empty string: field 1 omitted (proto3 default), field 2 = 0 omitted
	// Actually for ToothPaste compat we should always send both fields.
	// Field 1: tag=0x0a, len=0
	// Field 2: tag=0x10, varint=0
	want := []byte{0x0a, 0x00, 0x10, 0x00}
	if !bytes.Equal(got, want) {
		t.Errorf("MarshalKeyboardPacket(%q) = %x, want %x", "", got, want)
	}
}

func TestMarshalDataPacket(t *testing.T) {
	iv := make([]byte, 12)
	iv[0] = 0xAA
	tag := make([]byte, 16)
	tag[0] = 0xBB
	encrypted := []byte{0x01, 0x02, 0x03}
	packetNum := uint32(42)

	got := MarshalDataPacket(iv, tag, encrypted, packetNum)

	// Verify it starts with field 1 tag (0x0a) and length 12
	if len(got) < 2 || got[0] != 0x0a || got[1] != 12 {
		t.Errorf("DataPacket field 1 header: got %x, want 0a0c", got[:2])
	}

	// Just verify round-trip-ish: the packet should contain our iv, tag, encrypted data
	if !bytes.Contains(got, iv) {
		t.Error("DataPacket does not contain IV")
	}
	if !bytes.Contains(got, tag) {
		t.Error("DataPacket does not contain tag")
	}
	if !bytes.Contains(got, encrypted) {
		t.Error("DataPacket does not contain encrypted data")
	}
}

func TestUnmarshalResponsePacket(t *testing.T) {
	// Hand-craft a ResponsePacket: type=1 (PEER_STATUS), peer_status=0 (PEER_UNKNOWN), data=0xDE 0xAD
	raw := []byte{
		0x08, 0x01, // field 1: varint 1
		0x10, 0x00, // field 2: varint 0
		0x1a, 0x02, 0xDE, 0xAD, // field 3: bytes len=2
	}
	resp, err := UnmarshalResponsePacket(raw)
	if err != nil {
		t.Fatalf("UnmarshalResponsePacket() error = %v", err)
	}
	if resp.Type != ResponseTypePeerStatus {
		t.Errorf("Type = %d, want %d", resp.Type, ResponseTypePeerStatus)
	}
	if resp.PeerStatus != PeerStatusUnknown {
		t.Errorf("PeerStatus = %d, want %d", resp.PeerStatus, PeerStatusUnknown)
	}
	if !bytes.Equal(resp.Data, []byte{0xDE, 0xAD}) {
		t.Errorf("Data = %x, want dead", resp.Data)
	}
}

func TestUnmarshalResponsePacketInvalid(t *testing.T) {
	_, err := UnmarshalResponsePacket([]byte{0xFF})
	if err == nil {
		t.Error("expected error for invalid protobuf")
	}
}
```

**Step 2: Run tests to verify they fail**

Run: `task test` (or `go test ./internal/ble/protocol/ -v`)
Expected: compilation errors — package and functions don't exist yet.

**Step 3: Write minimal implementation**

```go
// internal/ble/protocol/proto.go
package protocol

import (
	"encoding/binary"
	"errors"
	"fmt"
)

// ResponseType is the type field in a ResponsePacket.
type ResponseType uint32

const (
	ResponseTypeKeepalive  ResponseType = 0
	ResponseTypePeerStatus ResponseType = 1
)

// PeerStatus indicates whether the ESP32 recognizes us.
type PeerStatus uint32

const (
	PeerStatusUnknown PeerStatus = 0
	PeerStatusKnown  PeerStatus = 1
)

// ResponsePacket is the decoded response from the ESP32.
type ResponsePacket struct {
	Type       ResponseType
	PeerStatus PeerStatus
	Data       []byte // challenge data during pairing
}

// MarshalKeyboardPacket encodes a KeyboardPacket protobuf.
//
//	field 1 (string): message
//	field 2 (uint32): length of message
func MarshalKeyboardPacket(message string) []byte {
	var buf []byte
	// Field 1: tag = (1 << 3) | 2 = 0x0a, length-delimited
	buf = append(buf, 0x0a)
	buf = appendVarint(buf, uint64(len(message)))
	buf = append(buf, message...)
	// Field 2: tag = (2 << 3) | 0 = 0x10, varint
	buf = append(buf, 0x10)
	buf = appendVarint(buf, uint64(len(message)))
	return buf
}

// MarshalEncryptedData wraps a serialized KeyboardPacket in an EncryptedData envelope.
// For ToothPaste, EncryptedData has a single field: KeyboardPacket (field 1, bytes).
func MarshalEncryptedData(keyboardPacket []byte) []byte {
	var buf []byte
	buf = append(buf, 0x0a)
	buf = appendVarint(buf, uint64(len(keyboardPacket)))
	buf = append(buf, keyboardPacket...)
	return buf
}

// MarshalDataPacket encodes a DataPacket protobuf (the outer encrypted wrapper).
//
//	field 1 (bytes): iv (12 bytes)
//	field 2 (bytes): tag (16 bytes)
//	field 3 (bytes): encrypted data
//	field 4 (uint32): packet_num
func MarshalDataPacket(iv, tag, encrypted []byte, packetNum uint32) []byte {
	var buf []byte
	// Field 1: iv
	buf = append(buf, 0x0a)
	buf = appendVarint(buf, uint64(len(iv)))
	buf = append(buf, iv...)
	// Field 2: tag
	buf = append(buf, 0x12)
	buf = appendVarint(buf, uint64(len(tag)))
	buf = append(buf, tag...)
	// Field 3: encrypted
	buf = append(buf, 0x1a)
	buf = appendVarint(buf, uint64(len(encrypted)))
	buf = append(buf, encrypted...)
	// Field 4: packet_num
	buf = append(buf, 0x20)
	buf = appendVarint(buf, uint64(packetNum))
	return buf
}

// UnmarshalResponsePacket decodes a ResponsePacket from raw protobuf bytes.
func UnmarshalResponsePacket(data []byte) (*ResponsePacket, error) {
	resp := &ResponsePacket{}
	for len(data) > 0 {
		if len(data) < 1 {
			return nil, errors.New("protocol: truncated response packet")
		}
		tagByte := data[0]
		fieldNum := tagByte >> 3
		wireType := tagByte & 0x07
		data = data[1:]

		switch wireType {
		case 0: // varint
			val, n, err := readVarint(data)
			if err != nil {
				return nil, fmt.Errorf("protocol: reading varint for field %d: %w", fieldNum, err)
			}
			data = data[n:]
			switch fieldNum {
			case 1:
				resp.Type = ResponseType(val)
			case 2:
				resp.PeerStatus = PeerStatus(val)
			}
		case 2: // length-delimited
			if len(data) < 1 {
				return nil, errors.New("protocol: truncated length in response packet")
			}
			length, n, err := readVarint(data)
			if err != nil {
				return nil, fmt.Errorf("protocol: reading length for field %d: %w", fieldNum, err)
			}
			data = data[n:]
			if uint64(len(data)) < length {
				return nil, fmt.Errorf("protocol: field %d length %d exceeds remaining %d bytes", fieldNum, length, len(data))
			}
			switch fieldNum {
			case 3:
				resp.Data = make([]byte, length)
				copy(resp.Data, data[:length])
			}
			data = data[length:]
		default:
			return nil, fmt.Errorf("protocol: unsupported wire type %d for field %d", wireType, fieldNum)
		}
	}
	return resp, nil
}

// appendVarint appends a protobuf varint to buf.
func appendVarint(buf []byte, v uint64) []byte {
	var tmp [binary.MaxVarintLen64]byte
	n := binary.PutUvarint(tmp[:], v)
	return append(buf, tmp[:n]...)
}

// readVarint reads a protobuf varint from data, returning value and bytes consumed.
func readVarint(data []byte) (uint64, int, error) {
	val, n := binary.Uvarint(data)
	if n <= 0 {
		return 0, 0, errors.New("protocol: invalid varint")
	}
	return val, n, nil
}
```

**Step 4: Run tests to verify they pass**

Run: `go test ./internal/ble/protocol/ -v`
Expected: all 5 tests PASS.

**Step 5: Commit**

```bash
git add internal/ble/protocol/
git commit -m "feat(ble): add protobuf hand-encoding for ToothPaste protocol

Marshal/unmarshal DataPacket, KeyboardPacket, EncryptedData, and
ResponsePacket without protoc dependency."
```

---

## Task 2: Text Chunking

Split text into BLE-MTU-safe chunks, UTF-8 aware, preferring word boundaries.

**Files:**
- Create: `internal/ble/protocol/chunk.go`
- Create: `internal/ble/protocol/chunk_test.go`

**Step 1: Write failing tests for chunking**

```go
// internal/ble/protocol/chunk_test.go
package protocol

import (
	"strings"
	"testing"
)

const testMaxBytes = 50 // small limit for easy testing

func TestChunkTextFitsInOne(t *testing.T) {
	chunks := ChunkText("hello world", testMaxBytes)
	if len(chunks) != 1 {
		t.Fatalf("got %d chunks, want 1", len(chunks))
	}
	if chunks[0] != "hello world" {
		t.Errorf("chunk[0] = %q, want %q", chunks[0], "hello world")
	}
}

func TestChunkTextEmpty(t *testing.T) {
	chunks := ChunkText("", testMaxBytes)
	if len(chunks) != 0 {
		t.Errorf("got %d chunks for empty string, want 0", len(chunks))
	}
}

func TestChunkTextSplitsAtWordBoundary(t *testing.T) {
	// 60 chars, should split into 2 chunks at a word boundary
	text := "the quick brown fox jumps over the lazy dog sleeping today"
	chunks := ChunkText(text, testMaxBytes)
	if len(chunks) < 2 {
		t.Fatalf("expected at least 2 chunks, got %d", len(chunks))
	}
	// Each chunk must be <= testMaxBytes
	for i, c := range chunks {
		if len(c) > testMaxBytes {
			t.Errorf("chunk[%d] len=%d exceeds max=%d", i, len(c), testMaxBytes)
		}
	}
	// Reassembled text must equal original
	reassembled := strings.Join(chunks, "")
	if reassembled != text {
		t.Errorf("reassembled = %q, want %q", reassembled, text)
	}
}

func TestChunkTextUTF8NeverSplitsMidChar(t *testing.T) {
	// Each emoji is 4 bytes. With max=10, can fit 2 emojis per chunk.
	text := "\U0001F600\U0001F601\U0001F602\U0001F603\U0001F604" // 5 emojis = 20 bytes
	chunks := ChunkText(text, 10)
	for i, c := range chunks {
		if len(c) > 10 {
			t.Errorf("chunk[%d] len=%d exceeds max=10", i, len(c))
		}
		// Each chunk must be valid UTF-8 (Go strings are valid by construction,
		// but verify no partial runes by checking rune count)
		for _, r := range c {
			if r == '\uFFFD' {
				t.Errorf("chunk[%d] contains replacement character (split mid-rune)", i)
			}
		}
	}
	reassembled := strings.Join(chunks, "")
	if reassembled != text {
		t.Errorf("reassembled = %q, want %q", reassembled, text)
	}
}

func TestChunkTextExactFit(t *testing.T) {
	text := strings.Repeat("a", testMaxBytes)
	chunks := ChunkText(text, testMaxBytes)
	if len(chunks) != 1 {
		t.Fatalf("got %d chunks, want 1", len(chunks))
	}
	if chunks[0] != text {
		t.Errorf("chunk[0] = %q, want %q", chunks[0], text)
	}
}

func TestChunkTextOneByteOver(t *testing.T) {
	text := strings.Repeat("a", testMaxBytes+1)
	chunks := ChunkText(text, testMaxBytes)
	if len(chunks) != 2 {
		t.Fatalf("got %d chunks, want 2", len(chunks))
	}
}

func TestChunkTextLongWordForced(t *testing.T) {
	// A single word longer than maxBytes must be split mid-word (but not mid-rune)
	text := strings.Repeat("x", testMaxBytes+10)
	chunks := ChunkText(text, testMaxBytes)
	if len(chunks) < 2 {
		t.Fatalf("got %d chunks, want >= 2", len(chunks))
	}
	reassembled := strings.Join(chunks, "")
	if reassembled != text {
		t.Errorf("reassembled length = %d, want %d", len(reassembled), len(text))
	}
}
```

**Step 2: Run tests to verify they fail**

Run: `go test ./internal/ble/protocol/ -v -run Chunk`
Expected: compilation error — `ChunkText` not defined.

**Step 3: Write minimal implementation**

```go
// internal/ble/protocol/chunk.go
package protocol

import "unicode/utf8"

// MaxPayloadBytes is the usable text bytes per BLE packet after
// protobuf framing + AES-GCM overhead (253 - ~40 bytes overhead).
const MaxPayloadBytes = 213

// ChunkText splits text into chunks that each fit within maxBytes.
// It prefers splitting at word boundaries (spaces) and never splits
// in the middle of a UTF-8 character. Returns nil for empty text.
func ChunkText(text string, maxBytes int) []string {
	if len(text) == 0 {
		return nil
	}
	if len(text) <= maxBytes {
		return []string{text}
	}

	var chunks []string
	for len(text) > 0 {
		if len(text) <= maxBytes {
			chunks = append(chunks, text)
			break
		}

		// Find the split point: start at maxBytes and walk back to find
		// a space. If no space found, split at the last valid UTF-8 boundary.
		split := maxBytes

		// Ensure we don't split in the middle of a UTF-8 character.
		// Walk back until we're at the start of a rune.
		for split > 0 && !utf8.RuneStart(text[split]) {
			split--
		}

		// Try to find a word boundary (space) by walking back from split.
		bestSpace := -1
		for i := split; i > 0; i-- {
			if text[i-1] == ' ' {
				bestSpace = i
				break
			}
		}

		if bestSpace > 0 {
			// Split at word boundary — include the space in the first chunk
			// so reassembly is exact.
			chunks = append(chunks, text[:bestSpace])
			text = text[bestSpace:]
		} else {
			// No space found — forced split at UTF-8 boundary
			chunks = append(chunks, text[:split])
			text = text[split:]
		}
	}
	return chunks
}
```

**Step 4: Run tests to verify they pass**

Run: `go test ./internal/ble/protocol/ -v -run Chunk`
Expected: all 7 chunk tests PASS.

**Step 5: Commit**

```bash
git add internal/ble/protocol/chunk.go internal/ble/protocol/chunk_test.go
git commit -m "feat(ble): add UTF-8 aware text chunking for BLE MTU

Splits text at word boundaries when possible, never splits mid-rune.
Default max payload is 213 bytes (253 BLE MTU minus framing overhead)."
```

---

## Task 3: Crypto Package (ECDH + AES-256-GCM + HKDF)

All security primitives needed for the ToothPaste protocol.

**Files:**
- Create: `internal/ble/crypto/crypto.go`
- Create: `internal/ble/crypto/crypto_test.go`

**Step 1: Write failing tests**

```go
// internal/ble/crypto/crypto_test.go
package crypto

import (
	"bytes"
	"crypto/ecdh"
	"testing"
)

func TestGenerateKeyPair(t *testing.T) {
	priv, pub, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("GenerateKeyPair() error = %v", err)
	}
	if priv == nil || pub == nil {
		t.Fatal("GenerateKeyPair() returned nil key")
	}
	// Compressed P-256 public key is 33 bytes
	compressed := CompressPublicKey(pub)
	if len(compressed) != 33 {
		t.Errorf("compressed public key length = %d, want 33", len(compressed))
	}
}

func TestDeriveSharedSecret(t *testing.T) {
	// Generate two key pairs and derive shared secret from both sides
	priv1, pub1, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("GenerateKeyPair() error = %v", err)
	}
	priv2, pub2, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("GenerateKeyPair() error = %v", err)
	}

	secret1, err := DeriveSharedSecret(priv1, pub2)
	if err != nil {
		t.Fatalf("DeriveSharedSecret(priv1, pub2) error = %v", err)
	}
	secret2, err := DeriveSharedSecret(priv2, pub1)
	if err != nil {
		t.Fatalf("DeriveSharedSecret(priv2, pub1) error = %v", err)
	}

	if !bytes.Equal(secret1, secret2) {
		t.Error("shared secrets from both sides do not match")
	}
}

func TestDeriveEncryptionKey(t *testing.T) {
	sharedSecret := make([]byte, 32)
	sharedSecret[0] = 0x42

	key, err := DeriveEncryptionKey(sharedSecret)
	if err != nil {
		t.Fatalf("DeriveEncryptionKey() error = %v", err)
	}
	if len(key) != 32 {
		t.Errorf("encryption key length = %d, want 32", len(key))
	}

	// Same input should produce same output (deterministic)
	key2, err := DeriveEncryptionKey(sharedSecret)
	if err != nil {
		t.Fatalf("DeriveEncryptionKey() second call error = %v", err)
	}
	if !bytes.Equal(key, key2) {
		t.Error("DeriveEncryptionKey is not deterministic")
	}
}

func TestEncryptDecryptRoundTrip(t *testing.T) {
	key := make([]byte, 32)
	key[0] = 0x01
	key[31] = 0xFF

	plaintext := []byte("hello from gostt-writer")

	iv, ciphertext, tag, err := Encrypt(key, plaintext)
	if err != nil {
		t.Fatalf("Encrypt() error = %v", err)
	}
	if len(iv) != 12 {
		t.Errorf("IV length = %d, want 12", len(iv))
	}
	if len(tag) != 16 {
		t.Errorf("tag length = %d, want 16", len(tag))
	}

	decrypted, err := Decrypt(key, iv, ciphertext, tag)
	if err != nil {
		t.Fatalf("Decrypt() error = %v", err)
	}
	if !bytes.Equal(decrypted, plaintext) {
		t.Errorf("Decrypt() = %q, want %q", decrypted, plaintext)
	}
}

func TestDecryptWrongKey(t *testing.T) {
	key := make([]byte, 32)
	plaintext := []byte("secret")

	iv, ciphertext, tag, err := Encrypt(key, plaintext)
	if err != nil {
		t.Fatalf("Encrypt() error = %v", err)
	}

	wrongKey := make([]byte, 32)
	wrongKey[0] = 0xFF

	_, err = Decrypt(wrongKey, iv, ciphertext, tag)
	if err == nil {
		t.Error("Decrypt() with wrong key should fail")
	}
}

func TestDecryptTamperedCiphertext(t *testing.T) {
	key := make([]byte, 32)
	plaintext := []byte("secret")

	iv, ciphertext, tag, err := Encrypt(key, plaintext)
	if err != nil {
		t.Fatalf("Encrypt() error = %v", err)
	}

	ciphertext[0] ^= 0xFF // tamper
	_, err = Decrypt(key, iv, ciphertext, tag)
	if err == nil {
		t.Error("Decrypt() with tampered ciphertext should fail")
	}
}

func TestParseCompressedPublicKey(t *testing.T) {
	_, pub, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("GenerateKeyPair() error = %v", err)
	}

	compressed := CompressPublicKey(pub)
	parsed, err := ParseCompressedPublicKey(compressed)
	if err != nil {
		t.Fatalf("ParseCompressedPublicKey() error = %v", err)
	}

	if !bytes.Equal(pub.Bytes(), parsed.Bytes()) {
		t.Error("round-tripped public key does not match original")
	}
}
```

**Step 2: Run tests to verify they fail**

Run: `go test ./internal/ble/crypto/ -v`
Expected: compilation errors — package doesn't exist.

**Step 3: Add dependency and write implementation**

First add the HKDF dependency:
```bash
go get golang.org/x/crypto/hkdf
```

```go
// internal/ble/crypto/crypto.go
package crypto

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/ecdh"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"errors"
	"fmt"
	"io"
	"math/big"

	"golang.org/x/crypto/hkdf"
)

// GenerateKeyPair creates a new ECDH P-256 key pair for BLE pairing.
func GenerateKeyPair() (*ecdh.PrivateKey, *ecdh.PublicKey, error) {
	curve := ecdh.P256()
	priv, err := curve.GenerateKey(rand.Reader)
	if err != nil {
		return nil, nil, fmt.Errorf("ble/crypto: generate key: %w", err)
	}
	return priv, priv.PublicKey(), nil
}

// CompressPublicKey returns the 33-byte SEC1 compressed form of a P-256 public key.
// The crypto/ecdh package's Bytes() returns the uncompressed form (65 bytes: 0x04 || x || y).
// We compress it to 33 bytes (0x02/0x03 || x) to match ToothPaste's format.
func CompressPublicKey(pub *ecdh.PublicKey) []byte {
	raw := pub.Bytes() // 65 bytes: 0x04 || x(32) || y(32)
	x := raw[1:33]
	y := new(big.Int).SetBytes(raw[33:65])

	compressed := make([]byte, 33)
	if y.Bit(0) == 0 {
		compressed[0] = 0x02
	} else {
		compressed[0] = 0x03
	}
	copy(compressed[1:], x)
	return compressed
}

// ParseCompressedPublicKey parses a 33-byte SEC1 compressed P-256 public key.
func ParseCompressedPublicKey(data []byte) (*ecdh.PublicKey, error) {
	if len(data) != 33 {
		return nil, fmt.Errorf("ble/crypto: compressed key must be 33 bytes, got %d", len(data))
	}
	if data[0] != 0x02 && data[0] != 0x03 {
		return nil, fmt.Errorf("ble/crypto: invalid compression prefix: 0x%02x", data[0])
	}

	// Decompress using elliptic package
	x := new(big.Int).SetBytes(data[1:33])
	curve := elliptic.P256()
	x2, y := elliptic.Unmarshal(curve, append([]byte{0x04}, append(data[1:33], make([]byte, 32)...)...))
	_ = x2

	// Actually, use the proper decompression
	y = decompressP256(x, data[0] == 0x03)
	if y == nil {
		return nil, errors.New("ble/crypto: point decompression failed")
	}

	// Build uncompressed form for ecdh
	uncompressed := make([]byte, 65)
	uncompressed[0] = 0x04
	xBytes := x.Bytes()
	copy(uncompressed[1+32-len(xBytes):33], xBytes)
	yBytes := y.Bytes()
	copy(uncompressed[33+32-len(yBytes):65], yBytes)

	pub, err := ecdh.P256().NewPublicKey(uncompressed)
	if err != nil {
		return nil, fmt.Errorf("ble/crypto: parse public key: %w", err)
	}
	return pub, nil
}

// decompressP256 recovers the y coordinate from x on the P-256 curve.
// oddY indicates whether y should be odd.
func decompressP256(x *big.Int, oddY bool) *big.Int {
	curve := elliptic.P256()
	params := curve.Params()
	p := params.P

	// y^2 = x^3 - 3x + b (mod p)
	x3 := new(big.Int).Mul(x, x)
	x3.Mul(x3, x)
	x3.Mod(x3, p)

	threeX := new(big.Int).Mul(big.NewInt(3), x)
	threeX.Mod(threeX, p)

	y2 := new(big.Int).Sub(x3, threeX)
	y2.Add(y2, params.B)
	y2.Mod(y2, p)

	// y = y2^((p+1)/4) mod p (works because p ≡ 3 mod 4 for P-256)
	exp := new(big.Int).Add(p, big.NewInt(1))
	exp.Rsh(exp, 2)
	y := new(big.Int).Exp(y2, exp, p)

	// Verify
	check := new(big.Int).Mul(y, y)
	check.Mod(check, p)
	if check.Cmp(y2) != 0 {
		return nil
	}

	// Adjust parity
	if oddY != (y.Bit(0) == 1) {
		y.Sub(p, y)
	}
	return y
}

// DeriveSharedSecret performs ECDH and returns the raw shared secret.
func DeriveSharedSecret(priv *ecdh.PrivateKey, peerPub *ecdh.PublicKey) ([]byte, error) {
	secret, err := priv.ECDH(peerPub)
	if err != nil {
		return nil, fmt.Errorf("ble/crypto: ECDH: %w", err)
	}
	return secret, nil
}

// DeriveEncryptionKey uses HKDF-SHA256 to derive a 32-byte AES key from the shared secret.
// Matches ToothPaste: HKDF(secret, salt=nil, info="toothpaste", length=32).
func DeriveEncryptionKey(sharedSecret []byte) ([]byte, error) {
	hkdfReader := hkdf.New(sha256.New, sharedSecret, nil, []byte("toothpaste"))
	key := make([]byte, 32)
	if _, err := io.ReadFull(hkdfReader, key); err != nil {
		return nil, fmt.Errorf("ble/crypto: HKDF: %w", err)
	}
	return key, nil
}

// Encrypt encrypts plaintext with AES-256-GCM, returning iv (12 bytes),
// ciphertext, and tag (16 bytes) separately (as ToothPaste expects them in separate protobuf fields).
func Encrypt(key, plaintext []byte) (iv, ciphertext, tag []byte, err error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("ble/crypto: new cipher: %w", err)
	}
	aead, err := cipher.NewGCM(block)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("ble/crypto: new GCM: %w", err)
	}

	iv = make([]byte, aead.NonceSize()) // 12 bytes
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return nil, nil, nil, fmt.Errorf("ble/crypto: random IV: %w", err)
	}

	// Go's GCM Seal appends the tag to the ciphertext
	sealed := aead.Seal(nil, iv, plaintext, nil)

	// Split: ciphertext is sealed[:len-tagSize], tag is sealed[len-tagSize:]
	tagSize := aead.Overhead() // 16
	ciphertext = sealed[:len(sealed)-tagSize]
	tag = sealed[len(sealed)-tagSize:]

	return iv, ciphertext, tag, nil
}

// Decrypt decrypts ciphertext with AES-256-GCM using separate iv, ciphertext, and tag.
func Decrypt(key, iv, ciphertext, tag []byte) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, fmt.Errorf("ble/crypto: new cipher: %w", err)
	}
	aead, err := cipher.NewGCM(block)
	if err != nil {
		return nil, fmt.Errorf("ble/crypto: new GCM: %w", err)
	}

	// Reassemble: ciphertext || tag (as Go's GCM expects)
	sealed := append(ciphertext, tag...)
	plaintext, err := aead.Open(nil, iv, sealed, nil)
	if err != nil {
		return nil, fmt.Errorf("ble/crypto: decrypt: %w", err)
	}
	return plaintext, nil
}
```

**Step 4: Run tests to verify they pass**

Run: `go test ./internal/ble/crypto/ -v`
Expected: all 7 tests PASS.

**Step 5: Commit**

```bash
go mod tidy
git add internal/ble/crypto/ go.mod go.sum
git commit -m "feat(ble): add ECDH key exchange and AES-256-GCM encryption

P-256 key generation, compressed key serialization, HKDF-SHA256 key
derivation, and AES-256-GCM encrypt/decrypt with separate IV and tag
fields matching the ToothPaste protocol."
```

---

## Task 4: Config — Add BLE Section

Extend the config to support `inject.ble` settings.

**Files:**
- Modify: `internal/config/config.go:42-45` (InjectConfig struct)
- Modify: `internal/config/config.go:119-156` (Validate)
- Modify: `internal/config/config_test.go` (add BLE config tests)
- Modify: `config.example.yaml` (document BLE fields)

**Step 1: Write failing tests**

Add to `internal/config/config_test.go`:

```go
func TestLoadBLEConfig(t *testing.T) {
	yamlContent := `
inject:
  method: ble
  ble:
    device_mac: "AA:BB:CC:DD:EE:FF"
    shared_secret: "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
    queue_size: 32
    reconnect_max: 15
`
	tmpDir := t.TempDir()
	cfgPath := filepath.Join(tmpDir, "config.yaml")
	if err := os.WriteFile(cfgPath, []byte(yamlContent), 0644); err != nil {
		t.Fatalf("failed to write test config: %v", err)
	}

	cfg, err := Load(cfgPath)
	if err != nil {
		t.Fatalf("Load() error = %v", err)
	}

	if cfg.Inject.Method != "ble" {
		t.Errorf("Inject.Method = %q, want %q", cfg.Inject.Method, "ble")
	}
	if cfg.Inject.BLE.DeviceMAC != "AA:BB:CC:DD:EE:FF" {
		t.Errorf("Inject.BLE.DeviceMAC = %q, want %q", cfg.Inject.BLE.DeviceMAC, "AA:BB:CC:DD:EE:FF")
	}
	if cfg.Inject.BLE.SharedSecret != "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" {
		t.Errorf("Inject.BLE.SharedSecret = %q", cfg.Inject.BLE.SharedSecret)
	}
	if cfg.Inject.BLE.QueueSize != 32 {
		t.Errorf("Inject.BLE.QueueSize = %d, want 32", cfg.Inject.BLE.QueueSize)
	}
	if cfg.Inject.BLE.ReconnectMax != 15 {
		t.Errorf("Inject.BLE.ReconnectMax = %d, want 15", cfg.Inject.BLE.ReconnectMax)
	}
}

func TestValidateBLEMethodRequiresPairing(t *testing.T) {
	cfg := Default()
	cfg.Inject.Method = "ble"
	// No BLE config set
	err := cfg.Validate()
	if err == nil {
		t.Error("Validate() should fail when method=ble but no device_mac")
	}
}

func TestValidateBLEMethodWithPairing(t *testing.T) {
	cfg := Default()
	cfg.Inject.Method = "ble"
	cfg.Inject.BLE.DeviceMAC = "AA:BB:CC:DD:EE:FF"
	cfg.Inject.BLE.SharedSecret = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
	err := cfg.Validate()
	if err != nil {
		t.Errorf("Validate() unexpected error: %v", err)
	}
}

func TestValidateBLEBadSharedSecret(t *testing.T) {
	cfg := Default()
	cfg.Inject.Method = "ble"
	cfg.Inject.BLE.DeviceMAC = "AA:BB:CC:DD:EE:FF"
	cfg.Inject.BLE.SharedSecret = "not-hex"
	err := cfg.Validate()
	if err == nil {
		t.Error("Validate() should fail for non-hex shared_secret")
	}
}

func TestBLEConfigDefaults(t *testing.T) {
	cfg := Default()
	if cfg.Inject.BLE.QueueSize != 0 {
		t.Errorf("default BLE.QueueSize = %d, want 0 (will use runtime default)", cfg.Inject.BLE.QueueSize)
	}
}

func TestLoadConfigWithoutBLESection(t *testing.T) {
	// Backward compat: configs without inject.ble should still load fine
	yamlContent := `
inject:
  method: type
`
	tmpDir := t.TempDir()
	cfgPath := filepath.Join(tmpDir, "config.yaml")
	if err := os.WriteFile(cfgPath, []byte(yamlContent), 0644); err != nil {
		t.Fatalf("failed to write test config: %v", err)
	}

	cfg, err := Load(cfgPath)
	if err != nil {
		t.Fatalf("Load() error = %v", err)
	}
	if cfg.Inject.Method != "type" {
		t.Errorf("Inject.Method = %q, want %q", cfg.Inject.Method, "type")
	}
	if cfg.Inject.BLE.DeviceMAC != "" {
		t.Errorf("Inject.BLE.DeviceMAC = %q, want empty", cfg.Inject.BLE.DeviceMAC)
	}
}
```

**Step 2: Run tests to verify they fail**

Run: `go test ./internal/config/ -v -run BLE`
Expected: compilation errors — `BLE` field doesn't exist on `InjectConfig`.

**Step 3: Write implementation**

In `internal/config/config.go`, add the `BLEConfig` struct and update `InjectConfig`:

```go
// InjectConfig holds text injection settings.
type InjectConfig struct {
	Method string    `yaml:"method"` // "type", "paste", or "ble"
	BLE    BLEConfig `yaml:"ble"`
}

// BLEConfig holds BLE output settings (used when inject.method is "ble").
type BLEConfig struct {
	DeviceMAC    string `yaml:"device_mac"`    // paired ESP32 MAC address
	SharedSecret string `yaml:"shared_secret"` // hex-encoded 32-byte AES key
	QueueSize    int    `yaml:"queue_size"`    // max queued messages during disconnect (default 64)
	ReconnectMax int    `yaml:"reconnect_max"` // max reconnect backoff in seconds (default 30)
}
```

Update `Validate()` to accept `"ble"` and validate BLE fields:

```go
switch c.Inject.Method {
case "type", "paste":
case "ble":
	if c.Inject.BLE.DeviceMAC == "" {
		return fmt.Errorf("inject.ble.device_mac required when inject.method is \"ble\" (run: task ble-pair)")
	}
	if c.Inject.BLE.SharedSecret == "" {
		return fmt.Errorf("inject.ble.shared_secret required when inject.method is \"ble\" (run: task ble-pair)")
	}
	if len(c.Inject.BLE.SharedSecret) != 64 {
		return fmt.Errorf("inject.ble.shared_secret must be 64 hex characters (32 bytes), got %d", len(c.Inject.BLE.SharedSecret))
	}
	if _, err := hex.DecodeString(c.Inject.BLE.SharedSecret); err != nil {
		return fmt.Errorf("inject.ble.shared_secret must be valid hex: %w", err)
	}
default:
	return fmt.Errorf("inject.method must be \"type\", \"paste\", or \"ble\", got %q", c.Inject.Method)
}
```

Add `"encoding/hex"` to imports.

**Step 4: Run tests to verify they pass**

Run: `go test ./internal/config/ -v`
Expected: all tests PASS (including existing tests — backward compat preserved).

**Step 5: Update config.example.yaml**

Add the BLE section to `config.example.yaml` after the existing inject section:

```yaml
# Text injection settings
inject:
  # Method: "type" = keystroke simulation (preserves clipboard),
  #         "paste" = clipboard + Cmd+V (faster but overwrites clipboard)
  #         "ble" = send to ESP32-S3 via Bluetooth Low Energy (requires pairing)
  method: type

  # BLE output settings (only used when method is "ble")
  # Run "task ble-pair" to pair with an ESP32-S3 running ToothPaste firmware.
  # device_mac and shared_secret are written automatically by the pairing command.
  # ble:
  #   device_mac: "AA:BB:CC:DD:EE:FF"
  #   shared_secret: "..."
  #   queue_size: 64        # max buffered messages during BLE disconnect (default: 64)
  #   reconnect_max: 30     # max reconnect backoff in seconds (default: 30)
```

**Step 6: Commit**

```bash
git add internal/config/ config.example.yaml
git commit -m "feat(config): add inject.ble section for BLE output

Adds BLEConfig struct with device_mac, shared_secret, queue_size, and
reconnect_max. Validates hex format and length when method is ble.
Backward compatible with existing configs."
```

---

## Task 5: BLE Adapter Interface & Mock

Define the BLE adapter interface so the client can be tested without hardware.

**Files:**
- Create: `internal/ble/adapter.go`
- Create: `internal/ble/mock_adapter_test.go`

**Step 1: Write the adapter interface and mock**

```go
// internal/ble/adapter.go
package ble

import "context"

// Characteristic represents a BLE GATT characteristic.
type Characteristic interface {
	// Write sends data to the characteristic.
	Write(data []byte) error
	// Subscribe registers a callback for notifications on this characteristic.
	Subscribe(callback func(data []byte)) error
}

// Device represents a discovered BLE peripheral.
type Device struct {
	Name    string
	MAC     string
	RSSI    int
}

// Connection represents an active BLE connection to a peripheral.
type Connection interface {
	// DiscoverCharacteristic finds a characteristic by UUID within a service.
	DiscoverCharacteristic(serviceUUID, charUUID string) (Characteristic, error)
	// Disconnect terminates the connection.
	Disconnect() error
	// OnDisconnect registers a callback invoked when the connection drops.
	OnDisconnect(callback func())
}

// Adapter abstracts the BLE hardware adapter for testing.
type Adapter interface {
	// Enable powers on the BLE adapter.
	Enable() error
	// Scan discovers BLE peripherals advertising the given service UUID.
	// Returns discovered devices until ctx is cancelled or timeout.
	Scan(ctx context.Context, serviceUUID string) ([]Device, error)
	// Connect establishes a connection to the device with the given MAC address.
	Connect(ctx context.Context, mac string) (Connection, error)
}
```

```go
// internal/ble/mock_adapter_test.go
package ble

import (
	"context"
	"sync"
	"testing"
)

// mockCharacteristic records writes and allows subscribing.
type mockCharacteristic struct {
	mu       sync.Mutex
	writes   [][]byte
	callback func([]byte)
}

func (c *mockCharacteristic) Write(data []byte) error {
	c.mu.Lock()
	defer c.mu.Unlock()
	cp := make([]byte, len(data))
	copy(cp, data)
	c.writes = append(c.writes, cp)
	return nil
}

func (c *mockCharacteristic) Subscribe(cb func([]byte)) error {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.callback = cb
	return nil
}

// SimulateNotification sends a notification to the subscriber.
func (c *mockCharacteristic) SimulateNotification(data []byte) {
	c.mu.Lock()
	cb := c.callback
	c.mu.Unlock()
	if cb != nil {
		cb(data)
	}
}

// mockConnection simulates a BLE connection.
type mockConnection struct {
	mu           sync.Mutex
	txChar       *mockCharacteristic
	respChar     *mockCharacteristic
	disconnectCb func()
	disconnected bool
}

func newMockConnection() *mockConnection {
	return &mockConnection{
		txChar:   &mockCharacteristic{},
		respChar: &mockCharacteristic{},
	}
}

func (c *mockConnection) DiscoverCharacteristic(serviceUUID, charUUID string) (Characteristic, error) {
	switch charUUID {
	case TXCharUUID:
		return c.txChar, nil
	case ResponseCharUUID:
		return c.respChar, nil
	default:
		return c.txChar, nil // fallback for tests
	}
}

func (c *mockConnection) Disconnect() error {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.disconnected = true
	return nil
}

func (c *mockConnection) OnDisconnect(cb func()) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.disconnectCb = cb
}

// SimulateDisconnect triggers the disconnect callback.
func (c *mockConnection) SimulateDisconnect() {
	c.mu.Lock()
	cb := c.disconnectCb
	c.mu.Unlock()
	if cb != nil {
		cb()
	}
}

// mockAdapter simulates the BLE adapter.
type mockAdapter struct {
	devices    []Device
	connection *mockConnection
}

func newMockAdapter(devices []Device) *mockAdapter {
	return &mockAdapter{
		devices:    devices,
		connection: newMockConnection(),
	}
}

func (a *mockAdapter) Enable() error { return nil }

func (a *mockAdapter) Scan(_ context.Context, _ string) ([]Device, error) {
	return a.devices, nil
}

func (a *mockAdapter) Connect(_ context.Context, _ string) (Connection, error) {
	return a.connection, nil
}

func TestMockAdapterImplementsInterface(t *testing.T) {
	var _ Adapter = (*mockAdapter)(nil)
}

func TestMockConnectionImplementsInterface(t *testing.T) {
	var _ Connection = (*mockConnection)(nil)
}

func TestMockCharacteristicImplementsInterface(t *testing.T) {
	var _ Characteristic = (*mockCharacteristic)(nil)
}
```

**Step 2: Run tests to verify they pass**

Run: `go test ./internal/ble/ -v`
Expected: 3 interface compliance tests PASS.

Note: We also need to define the UUID constants referenced by the mock. Add to `adapter.go`:

```go
// ToothPaste BLE UUIDs
const (
	ServiceUUID      = "19b10000-e8f2-537e-4f6c-d104768a1214"
	TXCharUUID       = "6856e119-2c7b-455a-bf42-cf7ddd2c5907"
	ResponseCharUUID = "6856e119-2c7b-455a-bf42-cf7ddd2c5908"
	MACCharUUID      = "19b10002-e8f2-537e-4f6c-d104768a1214"
)
```

**Step 3: Commit**

```bash
git add internal/ble/
git commit -m "feat(ble): define adapter interface and mock for testing

Adapter, Connection, and Characteristic interfaces abstract the BLE
hardware. MockAdapter enables full client testing without an ESP32."
```

---

## Task 6: BLE Client — Core Send Logic

The client that encrypts text, chunks it, and writes to the TX characteristic.

**Files:**
- Create: `internal/ble/client.go`
- Create: `internal/ble/client_test.go`

**Step 1: Write failing tests**

```go
// internal/ble/client_test.go
package ble

import (
	"strings"
	"testing"
	"time"
)

func makeTestKey() []byte {
	key := make([]byte, 32)
	key[0] = 0x42
	return key
}

func TestClientSendWritesToTX(t *testing.T) {
	adapter := newMockAdapter(nil)
	client := NewClient(adapter, "AA:BB:CC:DD:EE:FF", makeTestKey(), DefaultClientOptions())

	// Simulate an already-connected state
	client.setConnected(adapter.connection)

	err := client.Send("hello")
	if err != nil {
		t.Fatalf("Send() error = %v", err)
	}

	writes := adapter.connection.txChar.writes
	if len(writes) == 0 {
		t.Fatal("Send() produced no writes to TX characteristic")
	}
	// Each write should be a valid DataPacket (starts with 0x0a for field 1 = iv)
	if writes[0][0] != 0x0a {
		t.Errorf("first write byte = 0x%02x, want 0x0a (DataPacket field 1)", writes[0][0])
	}
}

func TestClientSendChunksLongText(t *testing.T) {
	adapter := newMockAdapter(nil)
	client := NewClient(adapter, "AA:BB:CC:DD:EE:FF", makeTestKey(), DefaultClientOptions())
	client.setConnected(adapter.connection)

	// Send text that exceeds one BLE packet
	longText := strings.Repeat("word ", 100) // 500 bytes
	err := client.Send(longText)
	if err != nil {
		t.Fatalf("Send() error = %v", err)
	}

	writes := adapter.connection.txChar.writes
	if len(writes) < 2 {
		t.Errorf("expected multiple writes for 500-byte text, got %d", len(writes))
	}
}

func TestClientSendEmptyString(t *testing.T) {
	adapter := newMockAdapter(nil)
	client := NewClient(adapter, "AA:BB:CC:DD:EE:FF", makeTestKey(), DefaultClientOptions())
	client.setConnected(adapter.connection)

	err := client.Send("")
	if err != nil {
		t.Fatalf("Send() error = %v", err)
	}

	// Empty string should produce no writes
	if len(adapter.connection.txChar.writes) != 0 {
		t.Errorf("Send(\"\") produced %d writes, want 0", len(adapter.connection.txChar.writes))
	}
}

func TestClientSendIncrementingPacketNum(t *testing.T) {
	adapter := newMockAdapter(nil)
	client := NewClient(adapter, "AA:BB:CC:DD:EE:FF", makeTestKey(), DefaultClientOptions())
	client.setConnected(adapter.connection)

	_ = client.Send("first")
	_ = client.Send("second")

	// Packet numbers should be incrementing (verified by the fact that
	// we got two separate writes with different content)
	writes := adapter.connection.txChar.writes
	if len(writes) != 2 {
		t.Fatalf("expected 2 writes, got %d", len(writes))
	}
	// The writes should differ (different IV, different packet_num, different ciphertext)
	if string(writes[0]) == string(writes[1]) {
		t.Error("two sends produced identical wire bytes (packet_num should differ)")
	}
}

func TestClientQueuesDuringDisconnect(t *testing.T) {
	adapter := newMockAdapter(nil)
	opts := DefaultClientOptions()
	opts.QueueSize = 4
	client := NewClient(adapter, "AA:BB:CC:DD:EE:FF", makeTestKey(), opts)

	// Client starts disconnected — Send should queue
	err := client.Send("queued message")
	if err != nil {
		t.Fatalf("Send() while disconnected should not error, got: %v", err)
	}

	if client.QueueLen() != 1 {
		t.Errorf("QueueLen() = %d, want 1", client.QueueLen())
	}
}

func TestClientQueueOverflow(t *testing.T) {
	adapter := newMockAdapter(nil)
	opts := DefaultClientOptions()
	opts.QueueSize = 2
	client := NewClient(adapter, "AA:BB:CC:DD:EE:FF", makeTestKey(), opts)

	// Fill queue
	_ = client.Send("msg1")
	_ = client.Send("msg2")
	_ = client.Send("msg3") // should drop oldest

	if client.QueueLen() != 2 {
		t.Errorf("QueueLen() = %d, want 2 (overflow should drop oldest)", client.QueueLen())
	}
}

func TestClientFlushQueueOnReconnect(t *testing.T) {
	adapter := newMockAdapter(nil)
	opts := DefaultClientOptions()
	opts.QueueSize = 4
	client := NewClient(adapter, "AA:BB:CC:DD:EE:FF", makeTestKey(), opts)

	// Queue messages while disconnected
	_ = client.Send("msg1")
	_ = client.Send("msg2")

	// Simulate reconnect
	client.setConnected(adapter.connection)
	client.flushQueue()

	// Allow async flush
	time.Sleep(50 * time.Millisecond)

	if client.QueueLen() != 0 {
		t.Errorf("QueueLen() after flush = %d, want 0", client.QueueLen())
	}

	writes := adapter.connection.txChar.writes
	if len(writes) != 2 {
		t.Errorf("expected 2 writes after flush, got %d", len(writes))
	}
}
```

**Step 2: Run tests to verify they fail**

Run: `go test ./internal/ble/ -v -run TestClient`
Expected: compilation errors — `NewClient`, `Client`, etc. don't exist.

**Step 3: Write implementation**

```go
// internal/ble/client.go
package ble

import (
	"log/slog"
	"sync"
	"sync/atomic"
	"time"

	blecrypto "github.com/chaz8081/gostt-writer/internal/ble/crypto"
	"github.com/chaz8081/gostt-writer/internal/ble/protocol"
)

// ClientOptions configures the BLE client behavior.
type ClientOptions struct {
	QueueSize    int // max queued messages during disconnect
	ReconnectMax int // max reconnect backoff in seconds
}

// DefaultClientOptions returns sensible defaults.
func DefaultClientOptions() ClientOptions {
	return ClientOptions{
		QueueSize:    64,
		ReconnectMax: 30,
	}
}

// Client manages the BLE connection to an ESP32-S3 running ToothPaste firmware.
type Client struct {
	adapter   Adapter
	deviceMAC string
	key       []byte // 32-byte AES encryption key

	mu        sync.Mutex
	conn      Connection
	txChar    Characteristic
	connected bool

	packetNum atomic.Uint32

	queue []string
	opts  ClientOptions
}

// NewClient creates a BLE client for the given paired device.
func NewClient(adapter Adapter, deviceMAC string, key []byte, opts ClientOptions) *Client {
	if opts.QueueSize <= 0 {
		opts.QueueSize = 64
	}
	if opts.ReconnectMax <= 0 {
		opts.ReconnectMax = 30
	}
	return &Client{
		adapter:   adapter,
		deviceMAC: deviceMAC,
		key:       key,
		opts:      opts,
	}
}

// Send encrypts and transmits text to the ESP32. If disconnected, the text
// is queued for delivery on reconnect. Safe for concurrent use.
func (c *Client) Send(text string) error {
	if text == "" {
		return nil
	}

	c.mu.Lock()
	if !c.connected {
		c.enqueue(text)
		c.mu.Unlock()
		return nil
	}
	txChar := c.txChar
	c.mu.Unlock()

	return c.sendChunked(txChar, text)
}

// sendChunked splits text into BLE-MTU-safe chunks, encrypts each, and writes.
func (c *Client) sendChunked(txChar Characteristic, text string) error {
	chunks := protocol.ChunkText(text, protocol.MaxPayloadBytes)
	for i, chunk := range chunks {
		if err := c.sendOne(txChar, chunk); err != nil {
			return err
		}
		// Small delay between chunks to avoid overwhelming the ESP32
		if i < len(chunks)-1 {
			time.Sleep(20 * time.Millisecond)
		}
	}
	return nil
}

// sendOne encrypts and sends a single chunk.
func (c *Client) sendOne(txChar Characteristic, text string) error {
	// Build inner protobuf
	kbPacket := protocol.MarshalKeyboardPacket(text)
	encData := protocol.MarshalEncryptedData(kbPacket)

	// Encrypt
	iv, ciphertext, tag, err := blecrypto.Encrypt(c.key, encData)
	if err != nil {
		return err
	}

	// Build outer DataPacket
	pktNum := c.packetNum.Add(1)
	dataPacket := protocol.MarshalDataPacket(iv, tag, ciphertext, pktNum)

	return txChar.Write(dataPacket)
}

// enqueue adds text to the send queue (caller must hold mu).
func (c *Client) enqueue(text string) {
	if len(c.queue) >= c.opts.QueueSize {
		// Drop oldest
		slog.Warn("[BLE] queue full, dropping oldest message")
		c.queue = c.queue[1:]
	}
	c.queue = append(c.queue, text)
}

// QueueLen returns the number of queued messages.
func (c *Client) QueueLen() int {
	c.mu.Lock()
	defer c.mu.Unlock()
	return len(c.queue)
}

// setConnected sets the connection state (for testing and reconnection).
func (c *Client) setConnected(conn Connection) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.conn = conn
	txChar, err := conn.DiscoverCharacteristic(ServiceUUID, TXCharUUID)
	if err != nil {
		slog.Error("[BLE] failed to discover TX characteristic", "error", err)
		return
	}
	c.txChar = txChar
	c.connected = true
}

// setDisconnected marks the client as disconnected.
func (c *Client) setDisconnected() {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.connected = false
	c.conn = nil
	c.txChar = nil
}

// flushQueue sends all queued messages. Call after reconnection.
func (c *Client) flushQueue() {
	c.mu.Lock()
	if !c.connected || len(c.queue) == 0 {
		c.mu.Unlock()
		return
	}
	queued := make([]string, len(c.queue))
	copy(queued, c.queue)
	c.queue = c.queue[:0]
	txChar := c.txChar
	c.mu.Unlock()

	for _, text := range queued {
		if err := c.sendChunked(txChar, text); err != nil {
			slog.Error("[BLE] failed to flush queued message", "error", err)
			// Re-queue remaining? For now, log and continue.
		}
	}
}

// Close gracefully disconnects the BLE client.
func (c *Client) Close() error {
	c.mu.Lock()
	defer c.mu.Unlock()

	if c.queue != nil && len(c.queue) > 0 {
		slog.Warn("[BLE] closing with unsent messages", "count", len(c.queue))
	}

	if c.conn != nil {
		c.conn.Disconnect()
	}
	c.connected = false
	return nil
}
```

**Step 4: Run tests to verify they pass**

Run: `go test ./internal/ble/ -v -run TestClient`
Expected: all 7 client tests PASS.

**Step 5: Commit**

```bash
git add internal/ble/client.go internal/ble/client_test.go
git commit -m "feat(ble): add BLE client with encryption, chunking, and queue

Client encrypts text with AES-256-GCM, chunks for BLE MTU, sends via
GATT write. Queues messages during disconnection with bounded overflow.
Incrementing packet numbers for replay protection."
```

---

## Task 7: BLE Client — Reconnection Logic

Add automatic reconnection with exponential backoff.

**Files:**
- Modify: `internal/ble/client.go` (add reconnect methods)
- Create: `internal/ble/reconnect_test.go`

**Step 1: Write failing tests**

```go
// internal/ble/reconnect_test.go
package ble

import (
	"testing"
	"time"
)

func TestReconnectBackoff(t *testing.T) {
	delays := []time.Duration{
		1 * time.Second,
		2 * time.Second,
		4 * time.Second,
		8 * time.Second,
		16 * time.Second,
		30 * time.Second, // capped
		30 * time.Second, // still capped
	}

	for i, want := range delays {
		got := backoffDelay(i, 30)
		if got != want {
			t.Errorf("backoffDelay(%d, 30) = %v, want %v", i, got, want)
		}
	}
}

func TestClientConnectAndReconnect(t *testing.T) {
	adapter := newMockAdapter([]Device{
		{Name: "ToothPaste-S3", MAC: "AA:BB:CC:DD:EE:FF", RSSI: -45},
	})
	client := NewClient(adapter, "AA:BB:CC:DD:EE:FF", makeTestKey(), DefaultClientOptions())

	// Connect
	err := client.Connect()
	if err != nil {
		t.Fatalf("Connect() error = %v", err)
	}

	c.mu.Lock()
	if !client.connected {
		t.Error("client should be connected after Connect()")
	}
	client.mu.Unlock()

	// Simulate disconnect
	adapter.connection.SimulateDisconnect()

	// Give reconnect goroutine a moment
	time.Sleep(100 * time.Millisecond)

	// The test mock reconnects immediately, so we should be reconnected
	client.mu.Lock()
	connected := client.connected
	client.mu.Unlock()
	// Note: actual reconnect depends on goroutine timing, just verify no panic
	_ = connected
}
```

**Step 2: Run tests to verify they fail**

Run: `go test ./internal/ble/ -v -run "Backoff|Reconnect"`
Expected: compilation errors — `backoffDelay`, `Connect` don't exist.

**Step 3: Write implementation**

Add to `internal/ble/client.go`:

```go
// backoffDelay returns the reconnection delay for attempt n, capped at maxSeconds.
func backoffDelay(attempt int, maxSeconds int) time.Duration {
	delay := time.Duration(1<<uint(attempt)) * time.Second
	max := time.Duration(maxSeconds) * time.Second
	if delay > max {
		return max
	}
	return delay
}

// Connect establishes the initial BLE connection to the paired device.
func (c *Client) Connect() error {
	if err := c.adapter.Enable(); err != nil {
		return fmt.Errorf("ble: enable adapter: %w", err)
	}

	ctx := context.Background()
	conn, err := c.adapter.Connect(ctx, c.deviceMAC)
	if err != nil {
		return fmt.Errorf("ble: connect to %s: %w", c.deviceMAC, err)
	}

	c.setConnected(conn)

	// Register disconnect handler for auto-reconnect
	conn.OnDisconnect(func() {
		slog.Warn("[BLE] disconnected, reconnecting...")
		c.setDisconnected()
		go c.reconnectLoop()
	})

	slog.Info("[BLE] connected", "mac", c.deviceMAC)
	return nil
}

// reconnectLoop attempts to reconnect with exponential backoff.
func (c *Client) reconnectLoop() {
	for attempt := 0; ; attempt++ {
		delay := backoffDelay(attempt, c.opts.ReconnectMax)
		slog.Info("[BLE] reconnect attempt", "attempt", attempt+1, "delay", delay)
		time.Sleep(delay)

		ctx := context.Background()
		conn, err := c.adapter.Connect(ctx, c.deviceMAC)
		if err != nil {
			slog.Warn("[BLE] reconnect failed", "error", err, "attempt", attempt+1)
			continue
		}

		c.setConnected(conn)
		slog.Info("[BLE] reconnected", "mac", c.deviceMAC)

		// Register disconnect handler again
		conn.OnDisconnect(func() {
			slog.Warn("[BLE] disconnected, reconnecting...")
			c.setDisconnected()
			go c.reconnectLoop()
		})

		// Flush queued messages
		c.flushQueue()
		return
	}
}
```

Add `"context"` and `"fmt"` to imports.

**Step 4: Fix test — the test has a typo (`c.mu.Lock()` should be `client.mu.Lock()`), fix and run**

Run: `go test ./internal/ble/ -v -run "Backoff|Reconnect"`
Expected: PASS.

**Step 5: Commit**

```bash
git add internal/ble/
git commit -m "feat(ble): add auto-reconnect with exponential backoff

Reconnects on disconnect with 1s, 2s, 4s... up to configurable max.
Flushes queued messages after successful reconnection."
```

---

## Task 8: BLE Injector (inject package integration)

Wire the BLE client into the existing injector interface.

**Files:**
- Modify: `internal/inject/inject.go` (add BLE case + injector interface)
- Create: `internal/inject/ble_injector.go`
- Create: `internal/inject/ble_injector_test.go`
- Modify: `cmd/gostt-writer/main.go` (wire BLE injector on startup)

**Step 1: Write failing test**

```go
// internal/inject/ble_injector_test.go
package inject

import "testing"

// mockBLESender records Send calls.
type mockBLESender struct {
	sent []string
}

func (m *mockBLESender) Send(text string) error {
	m.sent = append(m.sent, text)
	return nil
}

func TestBLEInjectorInject(t *testing.T) {
	mock := &mockBLESender{}
	inj := NewBLEInjector(mock)

	err := inj.Inject("hello world")
	if err != nil {
		t.Fatalf("Inject() error = %v", err)
	}
	if len(mock.sent) != 1 || mock.sent[0] != "hello world" {
		t.Errorf("sent = %v, want [\"hello world\"]", mock.sent)
	}
}

func TestBLEInjectorInjectEmpty(t *testing.T) {
	mock := &mockBLESender{}
	inj := NewBLEInjector(mock)

	err := inj.Inject("")
	if err != nil {
		t.Fatalf("Inject() error = %v", err)
	}
	if len(mock.sent) != 0 {
		t.Errorf("sent = %v, want empty", mock.sent)
	}
}
```

**Step 2: Run tests to verify they fail**

Run: `go test ./internal/inject/ -v -run BLE`
Expected: compilation errors.

**Step 3: Write implementation**

```go
// internal/inject/ble_injector.go
package inject

// BLESender is the interface the BLE client exposes for sending text.
type BLESender interface {
	Send(text string) error
}

// BLEInjector sends transcribed text over BLE to an ESP32-S3.
type BLEInjector struct {
	sender BLESender
}

// NewBLEInjector creates a BLEInjector backed by the given sender.
func NewBLEInjector(sender BLESender) *BLEInjector {
	return &BLEInjector{sender: sender}
}

// Inject sends text to the ESP32 via BLE.
func (b *BLEInjector) Inject(text string) error {
	if text == "" {
		return nil
	}
	return b.sender.Send(text)
}
```

**Step 4: Run tests to verify they pass**

Run: `go test ./internal/inject/ -v -run BLE`
Expected: PASS.

**Step 5: Commit**

```bash
git add internal/inject/ble_injector.go internal/inject/ble_injector_test.go
git commit -m "feat(inject): add BLEInjector for ESP32-S3 output

Implements the same Inject(text) pattern as local injectors, delegates
to the BLE client's Send method."
```

---

## Task 9: Wire BLE into main.go

Update the application entry point to support `inject.method: ble`.

**Files:**
- Modify: `cmd/gostt-writer/main.go`

**Step 1: Write the integration (no test file — this wires existing tested components)**

In `cmd/gostt-writer/main.go`, the current code creates an `*inject.Injector` directly:
```go
injector := inject.NewInjector(cfg.Inject.Method)
```

We need an interface so both local and BLE injectors can be used. Since the existing `Injector` already has `Inject(string) error`, define a minimal interface in the inject package and update main to use it.

Add to `internal/inject/inject.go`:
```go
// TextInjector is the interface for all injection methods.
type TextInjector interface {
	Inject(text string) error
}
```

Verify `*Injector` satisfies `TextInjector` (it already does — has `Inject(string) error`).
Verify `*BLEInjector` satisfies `TextInjector` (it does too).

Update `cmd/gostt-writer/main.go`:

```go
// Initialize text injector
var injector inject.TextInjector
switch cfg.Inject.Method {
case "ble":
	key, err := hex.DecodeString(cfg.Inject.BLE.SharedSecret)
	if err != nil {
		slog.Error("Invalid BLE shared secret", "error", err)
		os.Exit(1)
	}
	bleAdapter := ble.NewCoreBluetoothAdapter()
	bleClient := ble.NewClient(bleAdapter, cfg.Inject.BLE.DeviceMAC, key, ble.ClientOptions{
		QueueSize:    cfg.Inject.BLE.QueueSize,
		ReconnectMax: cfg.Inject.BLE.ReconnectMax,
	})
	if err := bleClient.Connect(); err != nil {
		slog.Error("BLE connection failed", "error", err,
			"hint", "Ensure ESP32-S3 is powered on and in range. Re-pair with: task ble-pair")
		os.Exit(1)
	}
	injector = inject.NewBLEInjector(bleClient)
	slog.Info("Text injector ready", "method", "ble", "device", cfg.Inject.BLE.DeviceMAC)
default:
	injector = inject.NewInjector(cfg.Inject.Method)
	slog.Info("Text injector ready", "method", cfg.Inject.Method)
}
```

Add BLE client cleanup in the shutdown handler:
```go
case sig := <-sigCh:
	slog.Info("Shutting down...", "signal", sig)
	if recorder.IsRecording() {
		recorder.Stop()
	}
	recorder.Close()
	transcriber.Close()
	if closer, ok := injector.(interface{ Close() error }); ok {
		closer.Close()
	}
	slog.Info("Goodbye!")
	os.Exit(0)
```

Add imports: `"encoding/hex"`, `"github.com/chaz8081/gostt-writer/internal/ble"`.

**Step 2: Verify build**

Run: `task build`
Expected: builds successfully.

Note: `ble.NewCoreBluetoothAdapter()` doesn't exist yet — it will be created in Task 10. For now, this task establishes the wiring pattern. The build won't succeed until Task 10 is complete. Consider stubbing the adapter temporarily or doing Tasks 9 and 10 together.

**Step 3: Commit (after Task 10)**

This task will be committed together with Task 10.

---

## Task 10: CoreBluetooth Adapter (tinygo-org/bluetooth wrapper)

Wrap `tinygo-org/bluetooth` to implement the `Adapter` interface.

**Files:**
- Create: `internal/ble/corebluetooth.go`
- Modify: `go.mod` (add tinygo-org/bluetooth dependency)

**Step 1: Add dependency**

```bash
go get tinygo.org/x/bluetooth
```

**Step 2: Write implementation**

```go
// internal/ble/corebluetooth.go
package ble

import (
	"context"
	"fmt"
	"sync"

	"tinygo.org/x/bluetooth"
)

// CoreBluetoothAdapter wraps tinygo-org/bluetooth for macOS.
type CoreBluetoothAdapter struct {
	adapter *bluetooth.Adapter
}

// NewCoreBluetoothAdapter creates a new BLE adapter using CoreBluetooth.
func NewCoreBluetoothAdapter() *CoreBluetoothAdapter {
	return &CoreBluetoothAdapter{
		adapter: bluetooth.DefaultAdapter,
	}
}

func (a *CoreBluetoothAdapter) Enable() error {
	return a.adapter.Enable()
}

func (a *CoreBluetoothAdapter) Scan(ctx context.Context, serviceUUID string) ([]Device, error) {
	uuid, err := bluetooth.ParseUUID(serviceUUID)
	if err != nil {
		return nil, fmt.Errorf("ble: parse service UUID: %w", err)
	}

	var mu sync.Mutex
	var devices []Device
	seen := make(map[string]bool)

	done := make(chan struct{})
	go func() {
		select {
		case <-ctx.Done():
			a.adapter.StopScan()
		case <-done:
		}
	}()

	err = a.adapter.Scan(func(adapter *bluetooth.Adapter, result bluetooth.ScanResult) {
		if !result.HasServiceUUID(uuid) {
			return
		}
		mac := result.Address.String()
		mu.Lock()
		defer mu.Unlock()
		if seen[mac] {
			return
		}
		seen[mac] = true
		devices = append(devices, Device{
			Name: result.LocalName(),
			MAC:  mac,
			RSSI: int(result.RSSI),
		})
	})
	close(done)

	if err != nil && ctx.Err() == nil {
		return nil, fmt.Errorf("ble: scan: %w", err)
	}
	return devices, nil
}

func (a *CoreBluetoothAdapter) Connect(ctx context.Context, mac string) (Connection, error) {
	addr := bluetooth.Address{}
	// Parse MAC - tinygo/bluetooth handles this per-platform
	// On macOS, addresses are UUIDs, not MAC addresses.
	// We'll need to scan and match by the stored address string.
	// For now, use the address as-is.

	// This is a simplified version. The real implementation will need to
	// scan for the device first, then connect to the scan result.
	// tinygo/bluetooth Connect() takes an Address.

	device, err := a.adapter.Connect(addr, bluetooth.ConnectionParams{})
	if err != nil {
		return nil, fmt.Errorf("ble: connect to %s: %w", mac, err)
	}

	return &coreBluetoothConnection{device: &device}, nil
}

// coreBluetoothConnection wraps a tinygo/bluetooth Device.
type coreBluetoothConnection struct {
	device       *bluetooth.Device
	disconnectCb func()
}

func (c *coreBluetoothConnection) DiscoverCharacteristic(serviceUUID, charUUID string) (Characteristic, error) {
	svcUUID, err := bluetooth.ParseUUID(serviceUUID)
	if err != nil {
		return nil, err
	}
	charUUIDParsed, err := bluetooth.ParseUUID(charUUID)
	if err != nil {
		return nil, err
	}

	svcs, err := c.device.DiscoverServices([]bluetooth.UUID{svcUUID})
	if err != nil {
		return nil, fmt.Errorf("ble: discover services: %w", err)
	}
	if len(svcs) == 0 {
		return nil, fmt.Errorf("ble: service %s not found", serviceUUID)
	}

	chars, err := svcs[0].DiscoverCharacteristics([]bluetooth.UUID{charUUIDParsed})
	if err != nil {
		return nil, fmt.Errorf("ble: discover characteristics: %w", err)
	}
	if len(chars) == 0 {
		return nil, fmt.Errorf("ble: characteristic %s not found", charUUID)
	}

	return &coreBluetoothCharacteristic{char: &chars[0]}, nil
}

func (c *coreBluetoothConnection) Disconnect() error {
	// tinygo/bluetooth doesn't have a direct Disconnect on macOS yet.
	// This is a known limitation. For now, this is a no-op.
	return nil
}

func (c *coreBluetoothConnection) OnDisconnect(cb func()) {
	c.disconnectCb = cb
	// Note: tinygo/bluetooth macOS support for disconnect callbacks
	// is limited. This may need platform-specific handling.
}

// coreBluetoothCharacteristic wraps a tinygo/bluetooth characteristic.
type coreBluetoothCharacteristic struct {
	char *bluetooth.DeviceCharacteristic
}

func (c *coreBluetoothCharacteristic) Write(data []byte) error {
	_, err := c.char.WriteWithoutResponse(data)
	return err
}

func (c *coreBluetoothCharacteristic) Subscribe(cb func([]byte)) error {
	return c.char.EnableNotifications(func(buf []byte) {
		cb(buf)
	})
}
```

> **Note:** The `tinygo-org/bluetooth` macOS API has some limitations (e.g., macOS uses UUIDs not MAC addresses for device identity, disconnect callbacks may need polling). These will need refinement during manual testing with real hardware. The interface abstraction means the core logic is fully tested via mocks regardless.

**Step 3: Verify build**

Run: `task build`
Expected: builds successfully.

**Step 4: Commit**

```bash
go mod tidy
git add internal/ble/corebluetooth.go internal/inject/inject.go cmd/gostt-writer/main.go go.mod go.sum
git commit -m "feat(ble): wire BLE output into main application

Adds CoreBluetooth adapter wrapping tinygo-org/bluetooth, TextInjector
interface in inject package, and BLE initialization in main.go when
inject.method is ble."
```

---

## Task 11: Pairing Command

Add `gostt-writer --ble-pair` flag and `task ble-pair` Taskfile entry.

**Files:**
- Modify: `cmd/gostt-writer/main.go` (add `--ble-pair` flag)
- Create: `internal/ble/pair.go`
- Create: `internal/ble/pair_test.go`
- Modify: `Taskfile.yml` (add `ble-pair` task)

**Step 1: Write failing tests for pairing logic**

```go
// internal/ble/pair_test.go
package ble

import (
	"testing"
)

func TestPairExchangeKeys(t *testing.T) {
	adapter := newMockAdapter([]Device{
		{Name: "ToothPaste-S3", MAC: "AA:BB:CC:DD:EE:FF", RSSI: -45},
	})

	// Simulate the ESP32 responding with a public key when we write ours.
	// This is a simplified test — the real flow involves characteristic notifications.
	result, err := Pair(adapter, "AA:BB:CC:DD:EE:FF")
	if err != nil {
		t.Fatalf("Pair() error = %v", err)
	}
	if result.DeviceMAC != "AA:BB:CC:DD:EE:FF" {
		t.Errorf("DeviceMAC = %q, want %q", result.DeviceMAC, "AA:BB:CC:DD:EE:FF")
	}
	if len(result.SharedSecret) != 32 {
		t.Errorf("SharedSecret length = %d, want 32", len(result.SharedSecret))
	}
}
```

**Step 2: Run tests to verify they fail**

Run: `go test ./internal/ble/ -v -run Pair`
Expected: compilation error — `Pair` function doesn't exist.

**Step 3: Write implementation**

```go
// internal/ble/pair.go
package ble

import (
	"context"
	"fmt"
	"time"

	blecrypto "github.com/chaz8081/gostt-writer/internal/ble/crypto"
	"github.com/chaz8081/gostt-writer/internal/ble/protocol"
)

// PairResult contains the data needed to save to config after pairing.
type PairResult struct {
	DeviceMAC    string
	SharedSecret []byte // 32-byte derived encryption key
}

// ScanForDevices scans for ESP32 devices advertising the ToothPaste service.
func ScanForDevices(adapter Adapter, timeout time.Duration) ([]Device, error) {
	if err := adapter.Enable(); err != nil {
		return nil, fmt.Errorf("ble: enable adapter: %w", err)
	}

	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()

	devices, err := adapter.Scan(ctx, ServiceUUID)
	if err != nil {
		return nil, err
	}
	return devices, nil
}

// Pair performs the ECDH key exchange with the specified device.
func Pair(adapter Adapter, deviceMAC string) (*PairResult, error) {
	if err := adapter.Enable(); err != nil {
		return nil, fmt.Errorf("ble: enable adapter: %w", err)
	}

	ctx := context.Background()
	conn, err := adapter.Connect(ctx, deviceMAC)
	if err != nil {
		return nil, fmt.Errorf("ble: connect for pairing: %w", err)
	}
	defer conn.Disconnect()

	// Discover characteristics
	txChar, err := conn.DiscoverCharacteristic(ServiceUUID, TXCharUUID)
	if err != nil {
		return nil, fmt.Errorf("ble: discover TX char: %w", err)
	}
	respChar, err := conn.DiscoverCharacteristic(ServiceUUID, ResponseCharUUID)
	if err != nil {
		return nil, fmt.Errorf("ble: discover response char: %w", err)
	}

	// Subscribe to response notifications
	peerPubKeyCh := make(chan []byte, 1)
	if err := respChar.Subscribe(func(data []byte) {
		resp, err := protocol.UnmarshalResponsePacket(data)
		if err != nil {
			return
		}
		// The ESP32 sends its public key as challenge data in a PEER_STATUS response
		if resp.Type == protocol.ResponseTypePeerStatus && len(resp.Data) == 33 {
			peerPubKeyCh <- resp.Data
		}
	}); err != nil {
		return nil, fmt.Errorf("ble: subscribe to responses: %w", err)
	}

	// Generate our ECDH keypair
	privKey, pubKey, err := blecrypto.GenerateKeyPair()
	if err != nil {
		return nil, err
	}

	// Send our compressed public key to the TX characteristic
	compressed := blecrypto.CompressPublicKey(pubKey)
	if err := txChar.Write(compressed); err != nil {
		return nil, fmt.Errorf("ble: write public key: %w", err)
	}

	// Wait for peer's public key (with timeout)
	select {
	case peerPubKeyBytes := <-peerPubKeyCh:
		peerPubKey, err := blecrypto.ParseCompressedPublicKey(peerPubKeyBytes)
		if err != nil {
			return nil, fmt.Errorf("ble: parse peer public key: %w", err)
		}

		// Derive shared secret
		sharedSecret, err := blecrypto.DeriveSharedSecret(privKey, peerPubKey)
		if err != nil {
			return nil, err
		}

		// Derive encryption key
		encKey, err := blecrypto.DeriveEncryptionKey(sharedSecret)
		if err != nil {
			return nil, err
		}

		return &PairResult{
			DeviceMAC:    deviceMAC,
			SharedSecret: encKey,
		}, nil

	case <-time.After(10 * time.Second):
		return nil, fmt.Errorf("ble: pairing timed out waiting for peer public key")
	}
}
```

Update the mock to simulate the pairing flow for tests — the mock's response characteristic should send back a public key when the TX characteristic receives one. Update `mock_adapter_test.go` to add pairing simulation:

```go
// In mockConnection constructor, set up auto-response for pairing
func newMockPairingConnection() *mockConnection {
	mc := newMockConnection()
	// When a 33-byte public key is written to TX, generate a peer key
	// and send it back via the response characteristic
	origWrite := mc.txChar.Write
	mc.txChar = &mockCharacteristic{
		writeHook: func(data []byte) {
			if len(data) == 33 && (data[0] == 0x02 || data[0] == 0x03) {
				// Generate a peer keypair and respond
				_, pub, _ := blecrypto.GenerateKeyPair()
				compressed := blecrypto.CompressPublicKey(pub)
				// Build a ResponsePacket with the peer's public key
				resp := []byte{0x08, 0x01, 0x10, 0x00} // type=1, peer_status=0
				resp = append(resp, 0x1a, byte(len(compressed)))
				resp = append(resp, compressed...)
				mc.respChar.SimulateNotification(resp)
			}
		},
	}
	return mc
}
```

> **Note:** The mock pairing test is simplified. The real pairing flow depends on the ESP32's exact handshake sequence. This will be refined during manual hardware testing.

**Step 4: Run tests**

Run: `go test ./internal/ble/ -v -run Pair`
Expected: PASS.

**Step 5: Add Taskfile entry and --ble-pair flag**

Add to `Taskfile.yml`:
```yaml
  ble-pair:
    desc: Pair with an ESP32-S3 running ToothPaste firmware
    cmds:
      - task build
      - ./{{.BINARY}} --ble-pair
    interactive: true
```

Add to `cmd/gostt-writer/main.go` (alongside existing flags):
```go
blePair := flag.Bool("ble-pair", false, "scan and pair with an ESP32-S3 BLE device")
```

And after flag parsing:
```go
if *blePair {
    runBLEPairing()
    return
}
```

The `runBLEPairing()` function handles scanning, device selection, pairing, and writing to config.

**Step 6: Commit**

```bash
git add internal/ble/pair.go internal/ble/pair_test.go cmd/gostt-writer/main.go Taskfile.yml
git commit -m "feat(ble): add BLE pairing command

Scans for ToothPaste devices, performs ECDH key exchange, saves
device_mac and shared_secret to config. Available via --ble-pair
flag or 'task ble-pair'."
```

---

## Task 12: Update README Privacy Section

Update the privacy section to reflect BLE.

**Files:**
- Modify: `README.md` (lines 168-200)

**Step 1: Edit the privacy section**

Change "zero network connections" to "zero internet connections" and add BLE documentation per the design doc's Section 7.

**Step 2: Commit**

```bash
git add README.md
git commit -m "docs: update privacy section for BLE output

Distinguish local BLE radio from internet connections. Document
encryption, explicit pairing requirement, and short-range nature."
```

---

## Task 13: Final Integration Test & Cleanup

Run full test suite, verify build, clean up.

**Files:** None new — verification only.

**Step 1: Run full test suite**

```bash
task test
```

Expected: all tests PASS.

**Step 2: Build**

```bash
task build
```

Expected: builds successfully.

**Step 3: Run linting (if configured)**

```bash
go vet ./...
```

Expected: no issues.

**Step 4: Final commit and push**

```bash
bd sync
git push
```

---

## Task Summary

| Task | Component | Key Files |
|------|-----------|-----------|
| 1 | Protobuf encoding | `internal/ble/protocol/proto.go` |
| 2 | Text chunking | `internal/ble/protocol/chunk.go` |
| 3 | Crypto (ECDH + AES) | `internal/ble/crypto/crypto.go` |
| 4 | Config BLE section | `internal/config/config.go` |
| 5 | Adapter interface | `internal/ble/adapter.go` |
| 6 | BLE client core | `internal/ble/client.go` |
| 7 | Reconnection logic | `internal/ble/client.go` |
| 8 | BLE injector | `internal/inject/ble_injector.go` |
| 9 | Main.go wiring | `cmd/gostt-writer/main.go` |
| 10 | CoreBluetooth adapter | `internal/ble/corebluetooth.go` |
| 11 | Pairing command | `internal/ble/pair.go`, `Taskfile.yml` |
| 12 | README privacy update | `README.md` |
| 13 | Final verification | (build + test) |

**Dependency order:** Tasks 1-5 are independent (can be parallelized). Task 6 depends on 1-3, 5. Task 7 depends on 6. Task 8 depends on 6. Tasks 9-10 depend on 4-8. Task 11 depends on 3, 5, 10. Task 12 is independent. Task 13 is last.

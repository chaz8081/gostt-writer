# https://taskfile.dev
version: "3"

# NOTE: Taskfile v3.46 uses gosh (built-in shell), NOT bash.
# fw-* tasks use firmware/esp32/idf.sh wrapper to run idf.py under real bash,
# since gosh doesn't propagate PATH changes from sourced scripts.
set: [errexit, pipefail]
shopt: [globstar]

vars:
  # Paths
  WHISPER_DIR: third_party/whisper.cpp
  WHISPER_BUILD: "{{.WHISPER_DIR}}/build_go"
  MODELS_DIR: models
  BIN_DIR: bin
  BINARY: "{{.BIN_DIR}}/gostt-writer"
  INSTALL_DIR: /usr/local/bin

  # ESP-IDF (override with IDF_PATH env var)
  IDF_PATH: '{{.IDF_PATH | default (print .HOME "/github/espressif/esp-idf")}}'

  # Version from git
  VERSION:
    sh: git describe --tags --always --dirty 2>/dev/null || echo "dev"

  # whisper.cpp include paths (match Go bindings conventions)
  INCLUDE_PATH: "{{.ROOT_DIR}}/{{.WHISPER_DIR}}/include:{{.ROOT_DIR}}/{{.WHISPER_DIR}}/ggml/include"
  GGML_METAL_PATH_RESOURCES: "{{.ROOT_DIR}}/{{.WHISPER_DIR}}"

  # Library paths: whisper, ggml, ggml-blas, ggml-metal
  LIBRARY_PATH: "{{.ROOT_DIR}}/{{.WHISPER_BUILD}}/src:{{.ROOT_DIR}}/{{.WHISPER_BUILD}}/ggml/src:{{.ROOT_DIR}}/{{.WHISPER_BUILD}}/ggml/src/ggml-blas:{{.ROOT_DIR}}/{{.WHISPER_BUILD}}/ggml/src/ggml-metal"

  # macOS linker flags
  EXT_LDFLAGS: -framework Foundation -framework Metal -framework MetalKit -framework CoreML -lggml-metal -lggml-blas

  # Whisper model
  MODEL_NAME: ggml-base.en.bin
  MODEL_URL: "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/{{.MODEL_NAME}}"
  MODEL_PATH: "{{.MODELS_DIR}}/{{.MODEL_NAME}}"

  # Parakeet TDT CoreML model
  PARAKEET_DIR: "{{.MODELS_DIR}}/parakeet-tdt-v2"
  PARAKEET_REPO: https://huggingface.co/FluidInference/parakeet-tdt-0.6b-v2-coreml

# Environment shared by build, test, and run
env:
  CGO_ENABLED: "1"
  C_INCLUDE_PATH: "{{.INCLUDE_PATH}}"
  LIBRARY_PATH: "{{.LIBRARY_PATH}}"
  GGML_METAL_PATH_RESOURCES: "{{.GGML_METAL_PATH_RESOURCES}}"

tasks:
  default:
    desc: Build everything (whisper.cpp + whisper model + binary)
    deps: [whisper, whisper-model, build]

  install:
    desc: Build, download models, and install to INSTALL_DIR (default /usr/local/bin)
    deps: [whisper]
    cmds:
      - task models
      - task build
      - |
        echo "Installing gostt-writer to {{.INSTALL_DIR}}..."
        mkdir -p {{.INSTALL_DIR}}
        cp {{.BINARY}} {{.INSTALL_DIR}}/gostt-writer
        echo "Installed gostt-writer to {{.INSTALL_DIR}}/gostt-writer"
    interactive: true

  models:
    desc: Download transcription models (interactive)
    cmds:
      - |
        OS="$(uname -s)"
        if [ "$OS" = "Darwin" ]; then
          echo ""
          echo "Which transcription model(s) would you like to download?"
          echo "  [1] whisper  - CPU/GPU via Metal (~140 MB)"
          echo "  [2] parakeet - Apple Neural Engine via CoreML (~443 MB)"
          echo "  [3] both"
          echo ""
          printf "Choose [1/2/3] (default: 1): "
          read -r choice
          choice="${choice:-1}"
        else
          echo "Non-macOS detected â€” downloading whisper model."
          choice="1"
        fi

        case "$choice" in
          1)
            task whisper-model
            ;;
          2)
            task parakeet-model
            ;;
          3)
            task whisper-model
            task parakeet-model
            ;;
          *)
            echo "Invalid choice: $choice"
            exit 1
            ;;
        esac
    interactive: true

  backend:
    desc: Switch the active transcription backend in your config
    vars:
      CONFIG_PATH:
        sh: echo "${HOME}/.config/gostt-writer/config.yaml"
    cmds:
      - |
        CONFIG="{{.CONFIG_PATH}}"

        if [ ! -f "$CONFIG" ]; then
          echo "Config not found at $CONFIG"
          echo "Run gostt-writer once to generate the default config, or create it manually."
          exit 1
        fi

        # Show current backend
        if grep -q '^transcribe:' "$CONFIG"; then
          CURRENT=$(awk '/^transcribe:/{found=1} found && /backend:/{gsub(/.*backend:[[:space:]]*/, ""); gsub(/["\x27]/, ""); print; exit}' "$CONFIG")
        fi
        CURRENT="${CURRENT:-whisper}"
        echo ""
        echo "Current backend: $CURRENT"
        echo ""
        echo "Which backend would you like to use?"
        echo "  [1] whisper  - CPU/GPU via Metal"
        echo "  [2] parakeet - Apple Neural Engine via CoreML"
        echo ""
        printf "Choose [1/2]: "
        read -r choice

        case "$choice" in
          1) NEW="whisper" ;;
          2) NEW="parakeet" ;;
          *)
            echo "Invalid choice: $choice"
            exit 1
            ;;
        esac

        if [ "$NEW" = "$CURRENT" ]; then
          echo "Already using $NEW, no change needed."
          exit 0
        fi

        # Update or add the transcribe.backend value
        if grep -q '^transcribe:' "$CONFIG"; then
          sed -i.bak "s/^\([[:space:]]*backend:[[:space:]]*\).*/\1$NEW/" "$CONFIG" && rm -f "$CONFIG.bak"
        else
          printf "\ntranscribe:\n  backend: %s\n" "$NEW" >> "$CONFIG"
        fi
        echo "Switched backend from $CURRENT to $NEW."
        echo "Restart gostt-writer for the change to take effect."
    interactive: true

  whisper:
    desc: Build whisper.cpp static library (Metal + Accelerate)
    preconditions:
      - sh: test -f {{.WHISPER_DIR}}/CMakeLists.txt
        msg: |
          whisper.cpp submodule not found. Run:
            git submodule update --init --recursive
    cmds:
      - >-
        cmake -S {{.WHISPER_DIR}} -B {{.WHISPER_BUILD}}
        -DCMAKE_BUILD_TYPE=Release
        -DBUILD_SHARED_LIBS=OFF
      - cmake --build {{.WHISPER_BUILD}} --target whisper
    sources:
      - "{{.WHISPER_DIR}}/CMakeLists.txt"
      - "{{.WHISPER_DIR}}/src/**/*"
      - "{{.WHISPER_DIR}}/include/**/*"
      - "{{.WHISPER_DIR}}/ggml/**/*"
    generates:
      - "{{.WHISPER_BUILD}}/src/libwhisper.a"
    status:
      - test -f {{.WHISPER_BUILD}}/src/libwhisper.a

  whisper-model:
    cmds:
      - mkdir -p {{.MODELS_DIR}}
      - curl -L -o {{.MODEL_PATH}} {{.MODEL_URL}}
    status:
      - test -f {{.MODEL_PATH}}

  parakeet-model:
    cmds:
      - mkdir -p {{.PARAKEET_DIR}}
      - |
        TMPDIR=$(mktemp -d)
        echo "Cloning from HuggingFace (sparse checkout)..."
        git clone --filter=blob:none --no-checkout {{.PARAKEET_REPO}} "$TMPDIR"
        cd "$TMPDIR"
        git sparse-checkout set Preprocessor.mlmodelc Encoder.mlmodelc Decoder.mlmodelc JointDecision.mlmodelc parakeet_vocab.json
        git checkout
        git lfs pull
        echo "Copying models to {{.PARAKEET_DIR}}..."
        cp -R Preprocessor.mlmodelc Encoder.mlmodelc Decoder.mlmodelc JointDecision.mlmodelc parakeet_vocab.json "{{.ROOT_DIR}}/{{.PARAKEET_DIR}}/"
        cd - > /dev/null
        rm -rf "$TMPDIR"
    status:
      - test -d {{.PARAKEET_DIR}}/Encoder.mlmodelc

  build:
    desc: Build the gostt-writer binary
    deps: [whisper]
    cmds:
      - mkdir -p {{.BIN_DIR}}
      - >-
        go build
        -ldflags "-X main.version={{.VERSION}} -extldflags '{{.EXT_LDFLAGS}}'"
        -o {{.BINARY}} ./cmd/gostt-writer
      - echo "Built {{.BINARY}}"
    sources:
      - "**/*.go"
      - go.mod
      - go.sum
    generates:
      - "{{.BINARY}}"

  run:
    desc: Build and run gostt-writer
    deps: [build]
    cmds:
      - ./{{.BINARY}}

  test:
    desc: Run all tests
    deps: [whisper]
    cmds:
      - >-
        go test
        -ldflags "-extldflags '{{.EXT_LDFLAGS}}'"
        -v ./...

  bench:
    desc: Run transcription benchmarks (RTF, WER, latency)
    deps: [whisper]
    cmds:
      - >-
        go test
        -ldflags "-extldflags '{{.EXT_LDFLAGS}}'"
        -bench=. -benchtime=3x -run='^$' -v
        ./internal/transcribe/

  clean:
    desc: Remove build artifacts
    cmds:
      - rm -rf {{.BIN_DIR}}
      - rm -rf {{.WHISPER_BUILD}}
      - go clean
      - echo "Cleaned build artifacts."

  ble-pair:
    desc: Pair with an ESP32-S3 running ToothPaste firmware
    deps: [build]
    cmds:
      - ./{{.BINARY}} --ble-pair
    interactive: true

  fw-test:
    desc: Run firmware host-side unit tests
    dir: firmware/esp32/test
    cmds:
      - make test_proto

  fw-setup:
    desc: Install ESP-IDF and USB serial driver (macOS)
    cmds:
      - |
        echo "=== ESP-IDF Setup ==="
        if [ ! -d "{{.IDF_PATH}}" ]; then
          echo "ESP-IDF not found at {{.IDF_PATH}}"
          echo "Install: https://docs.espressif.com/projects/esp-idf/en/stable/esp32s3/get-started/"
          echo "Or: mkdir -p $(dirname {{.IDF_PATH}}) && git clone --recursive https://github.com/espressif/esp-idf.git {{.IDF_PATH}} && {{.IDF_PATH}}/install.sh esp32s3"
          exit 1
        fi
        echo "ESP-IDF found at {{.IDF_PATH}}"

        echo ""
        echo "=== USB Serial Driver ==="
        if ls /dev/cu.wchusbserial* /dev/cu.usbserial* /dev/cu.usbmodem* /dev/cu.SLAB* >/dev/null 2>&1; then
          echo "USB serial port detected: $(ls /dev/cu.wchusbserial* /dev/cu.usbserial* /dev/cu.usbmodem* /dev/cu.SLAB* 2>/dev/null | head -1)"
        elif command -v brew >/dev/null 2>&1; then
          echo "No USB serial port found."
          echo "Most ESP32-S3 dev boards use a CH34x UART chip. Installing driver..."
          brew install --cask wch-ch34x-usb-serial-driver
          echo ""
          echo "IMPORTANT: Open /Applications/CH34xVCPDriver.app to activate the driver."
          echo "Then go to System Settings > General > Login Items & Extensions > Driver Extensions"
          echo "and enable the CH34x driver. Reboot, then plug in the board."
        else
          echo "No USB serial port found. Install the CH34x driver:"
          echo "  brew install --cask wch-ch34x-usb-serial-driver"
        fi

  fw-fullclean:
    desc: Full clean ESP32-S3 firmware build (removes build dir + managed components)
    dir: firmware/esp32
    cmds:
      - bash idf.sh fullclean

  fw-build:
    desc: Build ESP32-S3 firmware
    dir: firmware/esp32
    cmds:
      - bash idf.sh build

  fw-port:
    desc: Detect ESP32-S3 serial port
    silent: true
    cmds:
      - bash -c 'PORT="${FW_PORT:-$(ls /dev/cu.wchusbserial* /dev/cu.usbserial* /dev/cu.usbmodem* /dev/cu.SLAB* 2>/dev/null | head -1)}"; if [ -z "$PORT" ]; then echo "No ESP32-S3 found. Is the device plugged in?" >&2; echo "Run task fw-setup to install required drivers." >&2; exit 1; fi; echo "$PORT"'

  fw-flash:
    desc: Flash firmware to connected ESP32-S3
    dir: firmware/esp32
    cmds:
      - bash -c 'PORT="${FW_PORT:-$(ls /dev/cu.wchusbserial* /dev/cu.usbserial* /dev/cu.usbmodem* /dev/cu.SLAB* 2>/dev/null | head -1)}"; if [ -z "$PORT" ]; then echo "No ESP32-S3 found. Is the device plugged in?" >&2; echo "Run task fw-setup to install required drivers." >&2; exit 1; fi; echo "Flashing to $PORT..."; bash idf.sh -p "$PORT" flash'

  fw-monitor:
    desc: Serial monitor for ESP32-S3
    dir: firmware/esp32
    interactive: true
    cmds:
      - bash -c 'PORT="${FW_PORT:-$(ls /dev/cu.wchusbserial* /dev/cu.usbserial* /dev/cu.usbmodem* /dev/cu.SLAB* 2>/dev/null | head -1)}"; if [ -z "$PORT" ]; then echo "No ESP32-S3 found. Is the device plugged in?" >&2; echo "Run task fw-setup to install required drivers." >&2; exit 1; fi; bash idf.sh -p "$PORT" monitor'

  fw-flash-monitor:
    desc: Flash firmware and open serial monitor
    dir: firmware/esp32
    interactive: true
    cmds:
      - bash -c 'PORT="${FW_PORT:-$(ls /dev/cu.wchusbserial* /dev/cu.usbserial* /dev/cu.usbmodem* /dev/cu.SLAB* 2>/dev/null | head -1)}"; if [ -z "$PORT" ]; then echo "No ESP32-S3 found. Is the device plugged in?" >&2; echo "Run task fw-setup to install required drivers." >&2; exit 1; fi; echo "Flashing to $PORT..."; bash idf.sh -p "$PORT" flash monitor'
